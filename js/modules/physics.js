const Physics=(function(){const update=function(world,dt){const subSteps=4;const subDt=dt/subSteps;for(let i=subSteps;i>0;i--){applyGravity(world);applyConstraints(world);solveCollisions(world);updatePositions(world,subDt);}};const applyGravity=function(world){const gravity=world.settings.gravity;for(const particle of world.particles){particle.applyForce(gravity);}};const updatePositions=function(world,dt){for(const particle of world.particles){particle.update(dt);}};const applyConstraints=function(world){const {width,height}=world.settings.bounds;const buffer=1;for(const particle of world.particles){const {x,y}=particle.position;const r=particle.radius;if(y>height-r-buffer){particle.position.y=height-r-buffer;}if(y<r+buffer){particle.position.y=r+buffer;}if(x>width-r-buffer){particle.position.x=width-r-buffer;}if(x<r+buffer){particle.position.x=r+buffer;}}};const solveCollisions=function(world){const particles=world.particles;for(let i=0;i<particles.length;i++){for(let j=i+1;j<particles.length;j++){const p1=particles[i];const p2=particles[j];const distSq=p1.position.distanceSq(p2.position);const combinedRadius=p1.radius+p2.radius;if(distSq<combinedRadius*combinedRadius&&distSq>0.0001){const dist=Math.sqrt(distSq);const axis=Vector2.subtract(p1.position,p2.position).divide(dist);const overlap=combinedRadius-dist;const totalInvMass=p1.invMass+p2.invMass;if(totalInvMass<=0)continue;const p1Displacement=Vector2.multiply(axis,overlap*(p1.invMass/totalInvMass));const p2Displacement=Vector2.multiply(axis,overlap*(p2.invMass/totalInvMass));p1.position.add(p1Displacement);p2.position.subtract(p2Displacement);}}}};return{update:update};})();