const Physics=(function(){const update=function(world,dt){console.log(`[Physics]UpdateStart;dt:${dt}`);const subSteps=4;const subDt=dt/subSteps;for(let i=0;i<subSteps;i++){console.log(`[Physics]Sub-step ${i+1}/${subSteps}`);applyGravity(world);applyConstraints(world);solveCollisions(world);updatePositions(world,subDt);}console.log('[Physics]UpdateEnd.');};const applyGravity=function(world){console.log('[Physics]ApplyingGravity.');const gravity=world.settings.gravity;for(const particle of world.particles){particle.applyForce(gravity);}};const updatePositions=function(world,dt){console.log('[Physics]UpdatingPositions.');for(const particle of world.particles){particle.update(dt);}};const applyConstraints=function(world){console.log('[Physics]ApplyingConstraints.');const {width,height}=world.settings.bounds;const buffer=1;for(const particle of world.particles){const {x,y}=particle.position;const r=particle.radius;if(y>height-r-buffer){particle.position.y=height-r-buffer;console.log(`[Physics]Constrained ${particle.id} to bottom boundary.`);}if(y<r+buffer){particle.position.y=r+buffer;console.log(`[Physics]Constrained ${particle.id} to top boundary.`);}if(x>width-r-buffer){particle.position.x=width-r-buffer;console.log(`[Physics]Constrained ${particle.id} to right boundary.`);}if(x<r+buffer){particle.position.x=r+buffer;console.log(`[Physics]Constrained ${particle.id} to left boundary.`);}}};const solveCollisions=function(world){console.log('[Physics]SolvingCollisions.');const particles=world.particles;for(let i=0;i<particles.length;i++){for(let j=i+1;j<particles.length;j++){const p1=particles[i];const p2=particles[j];const distSq=p1.position.distanceSq(p2.position);const combinedRadius=p1.radius+p2.radius;if(distSq<combinedRadius*combinedRadius&&distSq>0.0001){const dist=Math.sqrt(distSq);const axis=Vector2.subtract(p1.position,p2.position).divide(dist);const overlap=combinedRadius-dist;console.log(`[Physics]CollisionDetected! p1:${p1.id}, p2:${p2.id}`,{overlap:overlap});const totalInvMass=p1.invMass+p2.invMass;if(totalInvMass<=0)continue;const p1Displacement=Vector2.multiply(axis,overlap*(p1.invMass/totalInvMass));const p2Displacement=Vector2.multiply(axis,overlap*(p2.invMass/totalInvMass));p1.position.add(p1Displacement);p2.position.subtract(p2Displacement);}}}};return{update:update};})();