const Physics=(function(){const update=function(world,dt){const subSteps=4;const subDt=dt/subSteps;for(let i=subSteps;i>0;i--){applyGravity(world);applyConstraints(world);updatePositions(world,subDt);solveCollisions(world);}};const applyGravity=function(world){const gravity=world.settings.gravity;for(const particle of world.particles){particle.applyForce(gravity);}};const updatePositions=function(world,dt){for(const particle of world.particles){particle.update(dt);}};const applyConstraints=function(world){const {width,height}=world.settings.bounds;const buffer=1;for(const particle of world.particles){const {x,y}=particle.position;const r=particle.radius;if(y>height-r-buffer){particle.position.y=height-r-buffer;}if(y<r+buffer){particle.position.y=r+buffer;}if(x>width-r-buffer){particle.position.x=width-r-buffer;}if(x<r+buffer){particle.position.x=r+buffer;}}};const solveCollisions=function(world){const particles=world.particles;for(let i=0;i<particles.length;i++){for(let j=i+1;j<particles.length;j++){const p1=particles[i];const p2=particles[j];const distSq=p1.position.distanceSq(p2.position);const combinedRadius=p1.radius+p2.radius;if(distSq<combinedRadius*combinedRadius){const dist=Math.sqrt(distSq);const overlap=(combinedRadius-dist)*0.5;const axis=Vector2.subtract(p1.position,p2.position).normalize();p1.position.add(Vector2.multiply(axis,overlap));p2.position.subtract(Vector2.multiply(axis,overlap));}}}};return{update:update};})();